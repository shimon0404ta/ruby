＠型
　ダブルクォーテーション（"）で囲ったものは、文字列型（String）
　ダブルクォーテーション（"）で囲っていないものは、整数型（Integer）

＠文字列型、整数型の型変換
　型が違うものを「+」で結合するとエラーが起きる。
　to_sメソッドは（整数型→文字列型へ変換）
　to_iメソッドは（文字列型→整数型へ変換）
　
＠変数とは
　変数は、文字列などのオブジェクトを作成した時に、そのオブジェクトにつける名札
　変数には、グローバル変数、ローカル変数など種類がある

＠定数とは
　定数は、あらかじめ変更しないことが保証された数値やデータに名札をつけたもの
　後から書き換える行為は非推奨な使い方
　
＠数値
　「1」「200」「-100」「0」などの整数、さらに「3.14」などの小数も含む。
　
＠文字列
　変数展開を用いると、元の変数がどのような型であっても文字列型に変換する。
　変数展開はダブルクォーテーションで囲った場合のみ機能し、 シングルクォーテーションで囲った場合は変数ではなく文字列として認識される。
　
＠配列
　複数のデータをまとめて保存できる。
　データ型は問われない。
　データを呼び出すには、配列名[インデックス番号]で記述
　
＠ハッシュ
　キーと値をセットで保存できるデータの集合
　ハッシュではインデックス番号ではなく、任意の値（キー）を割り振る
　
＠if式とは
　条件や状況に応じて実行内容を変えたい場合に使用。
　条件式の返り値が真か偽かに応じて処理を分岐させることができ、返り値が真の場合はif～endまでの処理が行われる。

＠条件式
　if式などの条件に記述する式のこと。
　式とは評価される値が定まり、その値が返されるもの。

＠真偽値
　falseとnilは偽、それ以外の値は真であり、このような真と偽の値を総称して真偽値という。
　真偽値とtrue, falseは必ずしもイコールではない。

＠比較演算子
　比較演算子は、値を比較して判定する際に使用。
　数値の大小を比較する演算子は「< 」「<=」 「>」「>=」の4種類がある。
　数値や文字列が同じかどうかを比較する演算子は「==」 「!=」の2種類がある。

＠論理演算子
　「論理演算子」は、2つ以上の条件を判定する際に使用。
　「!」「&&」「||」の3種類がある。
　複数の条件式をつなげる場合、カッコを用いて区切りをわかりやすくすることが大切。

＠elsif、else
　elseはifの条件に当てはまらなかった場合の処理を設定。
　elsifを使うことで条件・処理を追加することが可能。
　elsifはいくつでも追加可能。
　
＠gets
　キーボード入力された値を取得するメソッド
　getsを使うと、キー入力待ちの状態になり、文字を入力してEnterキーを押すまで次に進まない
　getsで入力した値は、文字列として返される
　
＠while式
　指定した条件によって繰り返しの有無が判断され、真（true）の間は繰り返し実行
　randは乱数といい、ランダムに数値を出力

＠for式
　指定したオブジェクトから順に値を取り出しながら繰り返し実行

＠each　
　オブジェクト内の要素を順に取り出す
　データの先頭から順に繰り返して処理が行われる。

＠break
　繰り返し処理を中断するメソッド
　while、for、eachなどの繰り返し文の中で利用
　
＠メソッドを定義する
　メソッドを定義するには、実行する処理内容をdef ～ end 内に記述
　メソッドを呼び出すには、そのメソッド名を記述
　定義したメソッドは、定義した後に呼び出さないとNameErrorが起きる
　メソッドは呼び出されない限り、処理が実行されない

＠引数とは
　「引数」は、メソッドを呼び出す際にメソッドに渡す値
　通常は、メソッド名(引数) の形で記述。引数は省略も可能。

＠戻り値とは
　戻り値（返り値）とは、メソッドの処理が終わった後に最終結果として返ってくる値である
　戻り値は、returnを使って指定することが出来る
　returnを省略した場合は、def ～ end 処理内の最終結果が戻り値

＠FizzBuzz
　FizzBuzz（フィズ・バズ）はシンプルなパーティゲーム
　FizzBuzzを作成できるかどうかで技術力がわかるため、コーディングの題材として使われている。
　
＠クラスとは
　メソッドなどをひとつにまとめた設計図のようなもの
　設計図がクラスだとすると、設計の内容にあたるのがメソッド
　書き方はclassの後に任意のクラス名、クラス名は始まりが大文字
　クラス内に記述されたメソッドをインスタンスメソッドという

＠インスタンスとは
　設計図をもとに作成される「モノ」がインスタンス
　書き方は、クラス名の後ろに.newをつける
　インスタンス名.メソッド名とすることで呼び出せる
　インスタンスは、クラスで書かれている設計を元に生成されるオブジェクトでもある

＠オブジェクトとは
　人や動物、車などありとあらゆるものがオブジェクト
　Rubyは、全てのデータをオブジェクトとして扱う
　オブジェクトは、必ずどこかのクラスに所属
　所属しているクラスによって使えるメソッドが変わる

＠selfとは
　selfは、オブジェクト自身の事
　クラスメソッド、レシーバとして使われるselfの2種類がある

＠クラスメソッド
　クラスメソッドは、クラスから実行できるメソッド
　クラス全体に関わる情報を変更するメソッドを作成するときなどに使用

＠レシーバのself
　レシーバとは、メソッドを呼び出したオブジェクト自身のこと
　( . )の左側の部分がレシーバ
　インスタンスメソッド内でselfを定義した場合、そのメソッドを呼び出したレシーバがselfの値
　この後に学習するRailsにも self を使う記述が出てくる
　
＠継承とは
　既にクラスで定義したメソッドを別のクラスでも受け継ぐことを継承という
　元となるクラスを親クラス（スーパークラス）
　メソッドを受け継ぎ、新しく作成するクラスを子クラス（サブクラス）
　子クラスから親クラスのメソッドを呼ぶことができる
　
　・継承のメリット
　　重複したコードがなくなり、スッキリとしたコードになる
　　複雑に見えるコードを可読性のあるコード(読みやすいコード)にできる

　・継承の書き方
　　クラス名の後に「<」を付けて継承したいクラス名を記述
　　親と子の関係だと、子クラス < 親クラス
　　どちらも始まりは大文字というルール

　・継承するべきか判断するポイント
　　「AはBの一種である」が成立するかどうか
　　上記のような関係のことをis-aの関係という
　　例えば、「バスは車の一種である」
　　
＠オーバーライドとは
　継承を行った「親子関係」であるクラスでは、メソッドを上書きできる
　親クラスで定義されたメソッド名と同じメソッド名を子クラスで定義し、メソッド内の処理を上書きすることを「オーバーライド」と言う
　親クラスのメソッドの中身が書き換えられるわけではなく、子クラス内で呼び出した時のみ、上書きされている
　親クラスのメソッドだけでは、実現したい機能が満たせず、子クラスで機能を追加したい場合などに利用

＠オーバーライドのメリット
　似ている機能を1つのメソッド名に合わせて、それぞれの子クラスで適した処理を定義する事ができる

＠superとは
　子クラスのメソッド内で定義すると、親クラス内にある同じ名前のメソッドを呼び出すことができる
　superの書き方は、メソッド内に「super」と定義するのみ

＠シンボルとは
　見た目は文字列のようで、内部では整数として扱われているオブジェクト
　文字列の前に、コロン(:)を付ける
　
　・シンボルと文字列の違いとは
　　シンボルは文字列の前にコロン(:)で定義する
　　　文字列はダブルクォーテーション（""）で囲んで定義する
　　シンボルは書き換えられない
　　　文字列は変更可能
　　シンボルは同じオブジェクトを参照している(一意性がある)
　　　文字列は同じオブジェクトではない
　　シンボルは文字列よりも処理が高速

　・どういう時に使うべきか
　　処理が高速であるため、検索を行う時
　　ハッシュのキーなど「同じものが複数あると困るもの」を扱う時
